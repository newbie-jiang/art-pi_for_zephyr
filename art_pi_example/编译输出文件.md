# 编译输出文件

```
west build -p always -b art_pi samples/hello_world
```

## 输出产物

```
hdj@hdj-virtual-machine:~/zephyrproject/zephyr$ cd build
hdj@hdj-virtual-machine:~/zephyrproject/zephyr/build$ tree -L 1
.
├── app
├── build_info.yml
├── build_info.yml.bak
├── build.ninja
├── CMakeCache.txt
├── CMakeFiles
├── cmake_install.cmake
├── compile_commands.json
├── Kconfig
├── modules
├── sysbuild_modules.txt
├── zephyr
├── zephyr_modules.txt
└── zephyr_settings.txt

5 directories, 9 files
hdj@hdj-virtual-machine:~/zephyrproject/zephyr/build$ cd zephyr/
hdj@hdj-virtual-machine:~/zephyrproject/zephyr/build/zephyr$ tree -L 1
.
├── arch
├── boards
├── cmake
├── CMakeFiles
├── cmake_install.cmake
├── drivers
├── edt.pickle
├── edt.pickle.cmake
├── include
├── isr_tables.c
├── isr_tables_swi.ld
├── isr_tables_vt.ld
├── kconfig
├── kernel
├── lib
├── libzephyr.a
├── linker.cmd
├── linker.cmd.dep
├── linker_zephyr_pre0.cmd
├── linker_zephyr_pre0.cmd.dep
├── misc
├── runners.yaml
├── snippets_generated.cmake
├── soc
├── subsys
├── syscall_weakdefs_llext.c
├── zephyr.bin
├── zephyr.dts
├── zephyr.dts.d
├── zephyr.dts.pre
├── zephyr.elf
├── zephyr_final.map
├── zephyr.hex
├── zephyr.map
├── zephyr_pre0.elf
├── zephyr_pre0.map
└── zephyr.stat

12 directories, 25 files

```

## 文件解释

# 一、`build/` 顶层常用

- **`compile_commands.json`**：所有源文件的**真实编译命令**（包含宏、包含路径、编译选项）。排查“为什么没找到头文件/宏不生效”的第一参考。
- **`build.ninja`**：Ninja 的规则与目标关系（已展开）。配合 `ninja -t commands <target>` 能看每个目标的实际命令。
- **`CMakeCache.txt`**：所有 CMake 变量的最终取值。追“这个选项是谁设的”的依据。
- **`build_info.yml`**：本次构建的元信息（board、app、git 版本等），`west flash`、runners 会用到。
- **`zephyr_modules.txt` / `sysbuild_modules.txt`**：本次参与构建的 Zephyr 模块列表（比如 hal、drivers 等），确认模块是否被纳入。
- **`zephyr/`**（目录）：Zephyr 内核与系统层的**目标产物与生成文件**都在这里（最常看的目录）。

# 二、`build/zephyr/` 关键文件

## 可执行与镜像

- **`zephyr.elf`**：最终 ELF（符号+段信息齐全）。用于仿真、回溯、调试（gdb/IDE）。
- **`zephyr.bin / zephyr.hex`**：烧录镜像（不少板子走 `.bin`；有些工具/MCU 用 `.hex`）。
- **`libzephyr.a`**：链接前的静态库聚合（内核、驱动等目标对象打包）。排“未定义引用/多重定义”可用 `arm-zephyr-eabi-nm` 看符号。

## 链接与内存布局

- **`linker.cmd`**：最终**链接脚本**（GNU ld）。看段放置、内存区（FLASH/SRAM/ITCM/DTCM）、对齐与保留节——定位“放不下/段放错”的首选。
- **`linker_zephyr_pre0.cmd`**：预链接阶段用的脚本（Zephyr 常有多阶段预链接来确定表和大小）。
- **`zephyr.map / zephyr_final.map / zephyr_pre0.map`**：**映射文件**，列出每个符号/段的地址与大小，精确定位谁占了内存、链接顺序、重定位问题。
- **`zephyr.stat`**：`size` 汇总（文本/数据/ bss），快速看总占用。

## 设备树 / 生成头

- **`zephyr.dts`**：**合并后的最终 DTS**（板级 + SoC + overlay），核对外设地址、中断号、内存区定义的真相。
- **`zephyr.dts.pre`**：预处理前的 DTS 展开体，便于对比 overlay 影响。
- **`include/generated/`（目录）**：
  - `autoconf.h`（Kconfig → 宏），
  - `devicetree_unfixed.h`（DTS → 宏），
  - `device_extern.h`、`offsets.h` 等。
     这是**应用代码实际看到的配置**。

## 中断/异常相关

- **`isr_tables.c`**：由脚本生成的**中断向量/ISR 列表源码**。若“中断没进/号错”，先看它。
- **`isr_tables_vt.ld / isr_tables_swi.ld`**：与向量表/软中断表相关的**链接片段**，参与最终链接脚本。

## 其它生成物/元数据

- **`edt.pickle / edt.pickle.cmake`**：Enhanced DT 的 Python 序列化中间件（供生成脚本使用）。
- **`snippets_generated.cmake`**：合并后的 CMake 片段（snippets）。
- **`syscall_weakdefs_llext.c`**：与系统调用/可加载扩展（llext）相关的弱定义源（按配置生成）。
- **`runners.yaml`**：`west flash/debug` 的 runner 参数（端口、复位方式、下载地址等）。
- **`arch/ boards/ drivers/ kernel/ lib/ soc/ subsys/`**：这些子目录里是分模块的对象与中间文件（便于按子系统定位问题）。

------

## 实战：遇到问题看哪一个？

- **编译选项/头文件路径不对** → `compile_commands.json`
- **符号没链接上/占用过大** → `zephyr.map` + `libzephyr.a`（配合 `nm`/`size`）
- **段/内存区放置错误、越界** → `linker.cmd` + `zephyr.map`
- **外设地址/中断号/别名错** → `zephyr.dts` + `include/generated/devicetree_unfixed.h`
- **中断不触发/向量表有误** → `isr_tables.c` + `isr_tables_vt.ld`
- **west flash/debug 参数怪** → `runners.yaml`
- **到底执行了什么命令** → 顶层 `build.ninja` + `ninja -t commands all`

需要我帮你根据**当前这个 `art_pi` 的镜像**读一遍 `zephyr.map`/`linker.cmd` 把内存占用和段布局标出来吗？